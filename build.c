/*
 * Copyright (c) 2024 furzoom.com, All rights reserved.
 * Author: mn, mn@furzoom.com
 *
 * Routines to construction the finite state machine for the MELON
 * parser generator.
 */

#include "build.h"

#include <stdio.h>
#include <stdlib.h>

#include "action.h"
#include "assert.h"
#include "configlist.h"
#include "error.h"
#include "plink.h"
#include "set.h"
#include "table.h"

/*
 * Find a precedence symbol of every rule in the grammar.
 *
 * Those rules which have a precedence symbol coded in the input
 * grammar using the "[symbol]" construct will already have the
 * rp->prec_sym field filled. Other rules take as their precedence
 * symbol the first RHS symbol with a defined precedence. If there
 * are not RHS symbols with a defined precedence, the precedence
 * symbol field is left blank.
 */
void MlnFindRulePrecedences(Melon *melon) {
  MlnRule *rp;
  for (rp = melon->rule; rp; rp = rp->next) {
    int i;
    if (rp->prec_sym != NULL) {
      continue;
    }

    for (i = 0; i < rp->nrhs; i++) {
      if (rp->rhs[i]->prec >= 0) {
        rp->prec_sym = rp->rhs[i];
        break;
      }
    }
  }
}

/*
 * Find all non-terminals which will generate the empty string.
 * Then go back and compute the first sets of every non-terminal.
 * The first set is the set of all terminal symbols which can begin
 * a string generated by that non-terminal.
 */
void MlnFindFirstSets(Melon *melon) {
  int i;
  MlnRule *rp;
  int progress;

  for (i = 0; i < melon->nsymbol; i++) {
    melon->symbols[i]->lambda = MLN_FALSE;
  }
  for (i = melon->nterminal; i < melon->nsymbol; i++) {
    melon->symbols[i]->first_set = MlnSetNew();
  }

  /* First compute all lambdas */
  do {
    progress = 0;
    for (rp = melon->rule; rp; rp = rp->next) {
      if (rp->lhs->lambda) {
        continue;
      }
      for (i = 0; i < rp->nrhs; i++) {
        if (rp->rhs[i]->lambda == MLN_FALSE) {
          break;
        }
      }
      if (i == rp->nrhs) {
        rp->lhs->lambda = MLN_TRUE;
        progress = 1;
      }
    }
  } while (progress != 0);

  /* Now compute all first sets */
  do {
    MlnSymbol *s1, *s2;
    progress = 0;
    for (rp = melon->rule; rp; rp = rp->next) {
      s1 = rp->lhs;
      for (i = 0; i < rp->nrhs; i++) {
        s2 = rp->rhs[i];
        if (s2->type == MLN_SYM_TERMINAL) {
          progress += MlnSetAdd(s1->first_set, s2->index);
          break;
        } else if (s1 == s2) {
          if (s1->lambda == MLN_FALSE) {
            break;
          }
        } else {
          progress += MlnSetUnion(s1->first_set, s2->first_set);
          if (s2->lambda == MLN_FALSE) {
            break;
          }
        }
      }
    }
  } while (progress != 0);
}

static MlnState *MlnGetState(Melon *melon);

/*
 * Compute all LR(0) states for the grammer. Links
 * are added to between some states so that the LR(1) follow sets
 * can be computed later.
 */
void MlnFindStates(Melon *melon) {
  MlnSymbol *sp;
  MlnRule *rp;

  MlnConfigListInit();

  /* Find the start symbol */
  if (melon->start) {
    sp = MlnSymbolFind(melon->start);
    if (sp == NULL) {
      MlnErrorMsg(melon->filename, 0,
                  "The specified start symbol \"%s\" is not in a non-terminal "
                  "of the grammar. \"%s\" will be used as the start symbol "
                  "instead.",
                  melon->start, melon->rule->lhs->name);
      melon->error_cnt++;
      sp = melon->rule->lhs;
    } else if (sp->rule == NULL) {
      MlnErrorMsg(melon->filename, 0,
                  "The specified start symbol \"%s\" doesn't have a rule. "
                  "\"%s\" will be used as the start symbol instead.",
                  melon->start, melon->rule->lhs->name);
      melon->error_cnt++;
      sp = melon->rule->lhs;
    }
  } else {
    sp = melon->rule->lhs;
  }

  /*
   * Make sure the start symbol doesn't occur on the right-hand side of
   * any rule. Report an error if it does. (YACC would generate a new
   * start symbol in this case.)
   */
  for (rp = melon->rule; rp != NULL; rp = rp->next) {
    int i;
    for (i = 0; i < rp->nrhs; i++) {
      if (rp->rhs[i] == sp) {
        MlnErrorMsg(melon->filename, 0,
                    "The start symbol \"%s\" occurs on the right-hand side of "
                    "a rule. This will result in a parser which does not work "
                    "properly.",
                    sp->name);
        melon->error_cnt++;
      }
    }
  }

  /*
   * The basis configuration set for the first state is all rules
   * which have the start symbol as their left-hand side.
   */
  for (rp = sp->rule; rp != NULL; rp = rp->next_lhs) {
    MlnConfig *new_cfg = MlnConfigListAddBasis(rp, 0);
    MlnSetAdd(new_cfg->fws, 0); /* add symbol "$" */
  }

  /*
   * Compute the first state. All other states will be computed automatically
   * during the computation of the first one. The returned pointer to the
   * first state is not used.
   */
  MlnGetState(melon);
}

static void MlnBuildShifts(Melon *melon, MlnState *state);

/*
 * Return a pointer to a state which is described by the configuration
 * list which has been built from calls to MlnConfigListAdd().
 */
static MlnState *MlnGetState(Melon *melon) {
  MlnConfig *bp;
  MlnConfig *cfp;
  MlnState *stp;

  /*
   * Extract the sorted basis of the new state. The basis was constructed
   * by prior calls to MlnConfigListAddBasis().
   */
  MlnConfigListSortBasis();
  bp = MlnConfigListBasis();

  /* Get a state with the same basis. */
  stp = MlnStateFind(bp);
  if (stp) {
    /* A state with the same basis already exists! Copy all the follow-set
     * propagation links from the state under construction into the
     * preexisting state, then return a pointer to the preexisting state.
     */
    MlnConfig *x, *y;
    for (x = bp, y = stp->bp; x && y; x = x->bp, y = y->bp) {
      MlnPLinkCopy(&y->bpl, x->bpl);
      MlnPLinkDelete(x->fpl);
      x->fpl = x->bpl = NULL;
    }
    cfp = MlnConfigListReturn();
    MlnConfigListEat(cfp);
  } else {
    /* This really is a new state. Construct all the details. */
    MlnConfigListClosure(melon); /* Compute the configuration closure */
    MlnConfigListSort();         /* Sort the configuration closure */
    cfp = MlnConfigListReturn(); /* Get a pointer to the config list */
    stp = MlnStateNew();         /* A new state structure */
    MlnMemoryCheck(stp);
    stp->bp = bp;                 /* Remember the configuration basis */
    stp->cfp = cfp;               /* Remember the configuration closure */
    stp->index = melon->nstate++; /* Every state gets a sequence number */
    stp->ap = NULL;               /* No actions, yet */
    MlnStateInsert(stp, stp->bp); /* Add to the state table */
    MlnBuildShifts(melon, stp);   /* Recursively compute successor states */
  }

  return stp;
}

/*
 * Construct all successor states to the given state. A "successor"
 * state is any state which can be reached by a shift action.
 */
static void MlnBuildShifts(Melon *melon, MlnState *state) {
  MlnConfig *cfp;   /* For looping thru the config closure of "state" */
  MlnConfig *bcfp;  /* For the inner loop on config closure of "state" */
  MlnConfig *new;   /**/
  MlnSymbol *sp;    /* Symbol following the dot in configuration "cfp" */
  MlnSymbol *bsp;   /* Symbol followint the dot in configuration "bcfp" */
  MlnState *newstp; /* A pointer to a successor state */

  /* Each configuration becomes complete aftet it contributes to a successor
   * state. Initially, all configurations are incomplete. */
  for (cfp = state->cfp; cfp != NULL; cfp = cfp->next) {
    cfp->status = MLN_INCOMPLETE;
  }

  /* Loop through all configurations of the state "state" */
  for (cfp = state->cfp; cfp != NULL; cfp = cfp->next) {
    /* Already used by inner loop. */
    if (cfp->status == MLN_COMPLETE) {
      continue;
    }

    /* Can't shift this config. */
    if (cfp->dot >= cfp->rule->nrhs) {
      continue;
    }
    MlnConfigListReset();          /* Reset the new config set. */
    sp = cfp->rule->rhs[cfp->dot]; /* Symbol after the dot. */

    /* For every configuration in the state "state" which has the symbol "sp"
     * following its dot, add the same configuration to the basis set under
     * construction but with the dot shifted one symbol to the right. */
    for (bcfp = cfp; bcfp != NULL; bcfp = bcfp->next) {
      /* Already used. */
      if (bcfp->status == MLN_COMPLETE) {
        continue;
      }
      /* Can't shift this one. */
      if (bcfp->dot >= bcfp->rule->nrhs) {
        continue;
      }
      bsp = bcfp->rule->rhs[bcfp->dot]; /* Get symbole after dot. */
      /* Must be same as for "cfp". */
      if (bsp != sp) {
        continue;
      }
      bcfp->status = MLN_COMPLETE; /* Mark this config as used. */
      new = MlnConfigListAddBasis(bcfp->rule, bcfp->dot + 1);
      MlnPLinkAdd(&new->bpl, bcfp);
    }

    /* Get a pointer to the state described by the basis configuration
     * set constructed in the preceding loop. */
    newstp = MlnGetState(melon);

    /* The state "newstp" is reached from the state "state" by a shift
     * action on the symbol "sp" */
    MlnActionAdd(&state->ap, MLN_SHIFT, sp, newstp);
  }
}

/*
 * Construct the propagation links.
 */
void MlnFindLinks(Melon *melon) {
  int i;

  /* Add to every propagate link a pointer back to the state to
   * which the link is attached. */
  for (i = 0; i < melon->nstate; i++) {
    MlnState *state = melon->sorted[i];
    MlnConfig *cfp;
    for (cfp = state->cfp; cfp != NULL; cfp = cfp->next) {
      cfp->st = state;
    }
  }

  /* Convert all backlinks into forward links. Only the forward
   * links are used in the follow-set computation. */
  for (i = 0; i < melon->nstate; i++) {
    MlnState *state = melon->sorted[i];
    MlnConfig *cfp;
    for (cfp = state->cfp; cfp != NULL; cfp = cfp->next) {
      MlnPLink *pl;
      for (pl = cfp->bpl; pl != NULL; pl = pl->next) {
        MlnConfig *other = pl->config;
        MlnPLinkAdd(&other->fpl, cfp);
      }
    }
  }
}

/* Compute all followsets.
 *
 * A followset is the set of all symbols which can come immediately
 * after a configuration.
 */
void MlnFindFollowSets(Melon *melon) {
  int i;
  int progress;

  for (i = 0; i < melon->nstate; i++) {
    MlnConfig *cfp;
    for (cfp = melon->sorted[i]->cfp; cfp != NULL; cfp = cfp->next) {
      cfp->status = MLN_INCOMPLETE;
    }
  }

  do {
    progress = 0;
    for (i = 0; i < melon->nstate; i++) {
      MlnConfig *cfp;
      for (cfp = melon->sorted[i]->cfp; cfp != NULL; cfp = cfp->next) {
        MlnPLink *pl;
        if (cfp->status == MLN_COMPLETE) {
          continue;
        }

        for (pl = cfp->fpl; pl != NULL; pl = pl->next) {
          int change = MlnSetUnion(pl->config->fws, cfp->fws);
          if (change != 0) {
            pl->config->status = MLN_INCOMPLETE;
            progress = 1;
          }
        }
        cfp->status = MLN_COMPLETE;
      }
    }
  } while (progress != 0);
}

static int MlnResolveConflict(MlnAction *apx, MlnAction *apy);

/*
 * Compute the reduce actions, and resolve conflicts.
 */
void MlnFindActions(Melon *melon) {
  int i, j;
  MlnSymbol *sym;
  MlnRule *rule;

  /* Add all of the reduce actions.
   *
   * A reduce action is added for each element of the followset of
   * a configuration which has its dot at the extreme right.
   */
  for (i = 0; i < melon->nstate; i++) {
    MlnState *state = melon->sorted[i];
    MlnConfig *cfp;
    for (cfp = state->cfp; cfp != NULL; cfp = cfp->next) {
      if (cfp->rule->nrhs == cfp->dot) { /* Is dot at extreme right? */
        for (j = 0; j < melon->nterminal; j++) {
          if (MlnSetFind(cfp->fws, j)) {
            /* Add a reduce action to the state "state" which will
             * reduce by the rule "cfp->rule" if the lookahead symbol
             * is "melon->symbols[j]".*/
            MlnActionAdd(&state->ap, MLN_REDUCE, melon->symbols[j], cfp->rule);
          }
        }
      }
    }
  }

  /* Add the accepting token */
  if (melon->start != NULL) {
    sym = MlnSymbolFind(melon->start);
    if (sym == NULL) {
      sym = melon->rule->lhs;
    }
  } else {
    sym = melon->rule->lhs;
  }

  /* Add to the first state (which is always the starting state of the
   * finite state machine) an action to MLN_ACCEPT if the lookahead is
   * the start nonterminal. */
  MlnActionAdd(&melon->sorted[0]->ap, MLN_ACCEPT, sym, NULL);

  /* Resolve conflicts */
  for (i = 0; i < melon->nstate; i++) {
    MlnState *state;
    MlnAction *ap, *nap;

    state = melon->sorted[i];
    assert(state->ap);
    state->ap = MlnActionSort(state->ap);
    for (ap = state->ap; ap != NULL && ap->next; ap = ap->next) {
      for (nap = ap->next; nap != NULL && nap->sym == ap->sym;
           nap = nap->next) {
        /* The two actions "ap" and "nap" have the same lookahead.
         * Figure out which one should be used */
        melon->nconflict += MlnResolveConflict(ap, nap);
      }
    }
  }

  /* Report an error for each rule that can never be reduced. */
  for (rule = melon->rule; rule != NULL; rule = rule->next) {
    rule->can_reduce = MLN_FALSE;
  }
  for (i = 0; i < melon->nstate; i++) {
    MlnAction *ap;
    for (ap = melon->sorted[i]->ap; ap != NULL; ap = ap->next) {
      if (ap->type == MLN_REDUCE) {
        ap->x.rule->can_reduce = MLN_TRUE;
      }
    }
  }
  for (rule = melon->rule; rule != NULL; rule = rule->next) {
    if (rule->can_reduce) {
      continue;
    }

    MlnErrorMsg(melon->filename, rule->rule_line,
                "This rule can not be reduced.\n");
    melon->error_cnt++;
  }
}

/*
 * Recude a conflict between the two given actions. If the conflict
 * can't be resolve, return non-zero.
 *
 * If either action is a MLN_SHIFT, the it must be apx. This
 * function won't work if apx->type == MLN_REDUCE, and apy == MLN_SHIFT.
 */
static int MlnResolveConflict(MlnAction *apx, MlnAction *apy) {
  int err_cnt = 0;
  assert(apx->sym == apy->sym); /* Otherwise there would be no conflict */
  if (apx->type == MLN_SHIFT && apy->type == MLN_REDUCE) {
    MlnSymbol *spx = apx->sym;
    MlnSymbol *spy = apy->x.rule->prec_sym;
    if (spy == NULL || spx->prec < 0 || spy->prec < 0) {
      /* Not enough precedence information */
      apy->type = MLN_CONFLICT;
      err_cnt++;
    } else if (spx->prec > spy->prec) { /* Lower precedence wins */
      apy->type = MLN_RD_RESOLVED;
    } else if (spx->prec < spy->prec) {
      apx->type = MLN_SH_RESOLVED;
    } else if (spx->prec == spy->prec && spx->assoc == MLN_ASSOC_RIGHT) {
      apy->type = MLN_RD_RESOLVED;
    } else if (spx->prec == spy->prec && spx->assoc == MLN_ASSOC_LEFT) {
      apx->type = MLN_SH_RESOLVED;
    } else {
      assert(spx->prec == spy->prec && spx->assoc == MLN_ASSOC_NONE);
      apy->type = MLN_CONFLICT;
      err_cnt++;
    }
  } else if (apx->type == MLN_REDUCE && apy->type == MLN_REDUCE) {
    MlnSymbol *spx = apx->x.rule->prec_sym;
    MlnSymbol *spy = apy->x.rule->prec_sym;
    if (spx == NULL || spy == NULL || spx->prec < 0 || spy->prec < 0 ||
        spx->prec == spy->prec) {
      spy->type = MLN_CONFLICT;
      err_cnt++;
    } else if (spx->prec > spy->prec) {
      apy->type = MLN_RD_RESOLVED;
    } else if (spx->prec < spy->prec) {
      apx->type = MLN_RD_RESOLVED;
    }
  } else {
    assert(apx->type == MLN_SH_RESOLVED || apx->type == MLN_RD_RESOLVED ||
           apx->type == MLN_CONFLICT || apy->type == MLN_SH_RESOLVED ||
           apy->type == MLN_RD_RESOLVED || apy->type == MLN_CONFLICT);
    /* The REDUCE/SHIFT case cannot happen because SHIFTs come before
     * REDUCEs on the list. If we reach this point it must be because
     * the parser conflict had already been resolved. */
  }
  return err_cnt;
}
